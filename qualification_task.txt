Stage 1

Generate input data that contains the next columns:

1. full_name - random first and second name (using memesis library). Can be male or female
2. credit_card_number - random VISA format ID (using memesis library)
3. credit_card_expiration_date - month/year the range between 01/2020 and 01/2025 (using memesis library)
4. gender - MALE/FEMALE
5. loan - a random floating point number uniformly distributed in the range between 1000 and 100000 and minimum step 1000

Data requirements:

1. There should be up to 12 records with the same full_name while the other data can be different. A particular number of such records should be uniformly distributed
2. The user-defined random number seed should be used to generate the same data again if you define the same seed. 
3. Data should be saved into a CSV file: 
InputData_YYYYMM_SEED_YYYYMMDDHHMMSS.csv, 
here YYYYMM - valuation_date (e.g. 2020/01), 
SEED - random number generator seed (see #2),
YYYYMMDDHHMMSS - timestamp of the moment when the file was published on the file system
4. The number of records is not limited but should be statistically representative

CODE SAMPLE USED FOR NUMPY ARRAY

import numpy as np

from mimesis import Person
from mimesis.providers.payment import Payment
from mimesis.enums import Gender, CardType


class DataGenerator:

    @staticmethod
    def generate_personal_data(num_records):
        person = Person('en')
        payment = Payment()

        dtype = np.dtype([
            ('id', np.unicode_, 16),
            ('full_name', np.unicode_, 32),
            ('credit_card_number', np.unicode_, 32),
            ('credit_card_expiration_date', np.unicode_, 8),
            ('gender', np.unicode_, 1),
        ])

        np.random.seed()
        rng = np.random.randint(0, 2, num_records)

        records_npy = np.empty(num_records, dtype=dtype)
        for idx in range(num_records):
        gender = Gender.MALE if rng[idx] == 0 else Gender.FEMALE
            records_npy['id'][idx] = str('{:016d}'.format(idx))
            records_npy['full_name'][idx] = person.full_name(gender=gender)
            records_npy['credit_card_number'][idx] = payment.credit_card_number(card_type=CardType.VISA)
            records_npy['credit_card_expiration_date'][idx] = payment.credit_card_expiration_date(maximum=21)
            records_npy['gender'][idx] = 'M' if rng[idx] == 0 else 'F'
        records_npy = records_npy[:num_records]

        return records_npy


if __name__ == '__main__':

    data = DataGenerator.generate_personal_data(100)
    print(data)


Stage 2

Data extraction, transformation and validation

A Numpy array of records should be created:

1. user_id - integer number (primary key, an identity of the user)
2. gender - integer number
3. expiration_date - integer year, integer month and integer day (end-of-month). Should be present as special numpy dtype
4. loan - floating point number array with a size 10 (number of payment programs)

Some separate tables will be useful too:
1. Mapping of the user_name to user_id (or backward)
2. Mapping of gender real name to its integer representation
3. Assuming we have 10 payment programs we can create a mapping of their ids to their names (e.g. P0, P2 etc. or any other unique names)

Validation
1. All users having repeatable records should be excluded if occurred in the initial file more 10 times. 
2. Such (#1) user_names should be stored in the invalid_user_list (can be numpy array of Unicode strings)

Fill in loan columns
1. The id_program is defined by the incremental sum of all digits in VISA id of the record until you get a one-digit number
2. Loans with the same id_program received from different records should be aggregated (sum)  ? ? ? ? ?

The result can be saved to MappedInputData_YYYYMM_SEED_YYYYMMDDHHMMSS.npy. Notice, YYYYMM_SEED_YYYYMMDDHHMMSS should be equal to CSV one so we can always track the sources


Stage 3

Simulation and Analysis

Assumptions (This data can be stored in numpy arrays):

standard_monthly_payment_rate = 1E-4
mortality_correction_for_payment_rate = MALE: 1.01, FEMALE: 0.99
fixed_to_floating_limit = 700000 
standard_deviation_for_flaoting_rate = P0: 0.01, P2: 0.01 ... P9: 0.09 (different for each program)

Calculation:

1. For each user record we do the projection starting from valuation_date (01/19) to the expiration_date
2. Each projection step is equal to one month
3. Loan on each step is an accumulated sum of current loan value + payment
4. Payment is calculated as the previous loan multiplied by payment rate and corresponding mortality correction
5. A standard rate can be floating or fixed depending on the total loan (sum of all 10 programs) of the user account (record). If a total loan is less than a limit then it is fixed otherwise it is floating
6. The floating payment rate is calculated as a random number generated by log-normal distribution with expected value equal to standard rate and corresponding stdev
7. user_id should be a seed of the random number generator used in #6
8. Each floating period should be calculated using 100 random number sequences (scenarios)

The result should be an array of loans with the size number of programs x number of scenarios (10 x 100). These results should be saved to LoanData_YYYYMM_SEED_YYYYMMDDHHMMSS.npy


Analysis

1. Plot histogram for each program and total 
2. Calculate corresponding Expected Values and 5%, 25%, 75%, 95% Quantiles

FEEL FREE TO PLAY WITH NUMBERS TO MAKE RESULTS BEAUTIFUL

 